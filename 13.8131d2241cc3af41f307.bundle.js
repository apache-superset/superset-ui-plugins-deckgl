(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{1021:function(t,e,n){"use strict";var i=n(63),o=n(922),s=n(36),r=n(462),a=n(461),c=n(941),l=n(942);class p extends l.a{constructor(t){super(t=>this.format(t));const{id:e=Object(c.a)("config.id"),label:n,description:i="",formatFunc:o=Object(c.a)("config.formatFunc"),isInvalid:s=!1}=t;this.id=e,this.label=null!=n?n:e,this.description=i,this.formatFunc=o,this.isInvalid=s}format(t){return null==t||Number.isNaN(t)?`${t}`:t===Number.POSITIVE_INFINITY?"∞":t===Number.NEGATIVE_INFINITY?"-∞":this.formatFunc(t)}preview(t=12345.432){return`${t} => ${this.format(t)}`}}var f=p;var u={DOLLAR:"$,.2f",DOLLAR_ROUND:"$,d",DOLLAR_ROUND_SIGNED:"+$,d",DOLLAR_SIGNED:"+$,.2f",FLOAT:",.2f",FLOAT_1_POINT:",.1f",FLOAT_2_POINT:",.2f",FLOAT_3_POINT:",.3f",FLOAT_SIGNED:"+,.2f",FLOAT_SIGNED_1_POINT:"+,.1f",FLOAT_SIGNED_2_POINT:"+,.2f",FLOAT_SIGNED_3_POINT:"+,.3f",INTEGER:",d",INTEGER_SIGNED:"+,d",PERCENT:",.2%",PERCENT_1_POINT:",.1%",PERCENT_2_POINT:",.2%",PERCENT_3_POINT:",.3%",PERCENT_SIGNED:"+,.2%",PERCENT_SIGNED_1_POINT:"+,.1%",PERCENT_SIGNED_2_POINT:"+,.2%",PERCENT_SIGNED_3_POINT:"+,.3%",SI:".3s",SI_1_DIGIT:".1s",SI_2_DIGIT:".2s",SI_3_DIGIT:".3s",SMART_NUMBER:"SMART_NUMBER",SMART_NUMBER_SIGNED:"SMART_NUMBER_SIGNED"};const h=Object(r.a)(".3~s"),d=Object(r.a)(".2~f"),g=Object(r.a)(".4~f");function v(t={}){const{description:e,signed:n=!1,id:i,label:o}=t,s=n?t=>t>0?"+":"":()=>"";return new f({description:e,formatFunc:t=>`${s(t)}${function(t){if(0===t)return"0";const e=Math.abs(t);return e>=1e3?h(t).replace("G","B"):e>=1?d(t):e>=.001?g(t):e>1e-6?`${h(1e6*t)}µ`:h(t)}(t)}`,id:i||n?u.SMART_NUMBER_SIGNED:u.SMART_NUMBER,label:null!=o?o:"Adaptive formatter"})}class P extends o.a{constructor(){super({name:"NumberFormatter",overwritePolicy:s.a.WARN}),this.registerValue(u.SMART_NUMBER,v()),this.registerValue(u.SMART_NUMBER_SIGNED,v({signed:!0})),this.setDefaultKey(u.SMART_NUMBER)}get(t){const e=`${null==t||""===t?this.defaultKey:t}`.trim();if(this.has(e))return super.get(e);const n=function(t){const{description:e,formatString:n=Object(c.a)("config.formatString"),label:i,locale:o}=t;let s,l=!1;try{s=void 0===o?Object(r.a)(n):Object(a.a)(o).format(n)}catch(t){s=t=>`${t} (Invalid format: ${n})`,l=!0}return new f({description:e,formatFunc:s,id:n,isInvalid:l,label:i})}({formatString:e});return this.registerValue(e,n),n}format(t,e){return this.get(t)(e)}}n.d(e,"a",(function(){return y}));const m=Object(i.a)(P);function y(t,e){return m().format(t,e)}},1022:function(t,e,n){"use strict";var i=n(945),o=n(946),s=n(948),r=n(947),a=n(958),c=n(949),l=n(1005),p=n(1136),f=n(1071),u=n(952),h=n(1294),d=u.a.Tesselator,g=h.a.fp64LowPart,v=function(t){function e(t){var n=t.data,o=t.getGeometry,a=t.positionFormat,c=t.fp64;return Object(i.a)(this,e),Object(s.a)(this,Object(r.a)(e).call(this,{data:n,getGeometry:o,fp64:c,positionFormat:a,attributes:{startPositions:{size:3},endPositions:{size:3},leftPositions:{size:3},rightPositions:{size:3},startEndPositions64XyLow:{size:4,fp64Only:!0},neighborPositions64XyLow:{size:4,fp64Only:!0}}}))}return Object(c.a)(e,t),Object(o.a)(e,[{key:"get",value:function(t){return this.attributes[t]}},{key:"getGeometrySize",value:function(t){return Math.max(0,this.getPathLength(t)-1)}},{key:"updateGeometryAttributes",value:function(t,e){var n=this.attributes,i=n.startPositions,o=n.endPositions,s=n.leftPositions,r=n.rightPositions,a=n.startEndPositions64XyLow,c=n.neighborPositions64XyLow,l=this.fp64,p=e.geometrySize+1;if(!(p<2))for(var f,u=this.isClosed(t),h=this.getPointOnPath(t,0),d=this.getPointOnPath(t,1),v=u?this.getPointOnPath(t,p-2):h,P=e.vertexStart,m=1;m<p;P++,m++)f=m+1<p?this.getPointOnPath(t,m+1):u?this.getPointOnPath(t,1):d,i[3*P]=h[0],i[3*P+1]=h[1],i[3*P+2]=h[2]||0,o[3*P]=d[0],o[3*P+1]=d[1],o[3*P+2]=d[2]||0,s[3*P]=v[0],s[3*P+1]=v[1],s[3*P+2]=v[2]||0,r[3*P]=f[0],r[3*P+1]=f[1],r[3*P+2]=f[2]||0,l&&(a[4*P]=g(h[0]),a[4*P+1]=g(h[1]),a[4*P+2]=g(d[0]),a[4*P+3]=g(d[1]),c[4*P]=g(v[0]),c[4*P+1]=g(v[1]),c[4*P+2]=g(f[0]),c[4*P+3]=g(f[1])),v=h,h=d,d=f}},{key:"getPathLength",value:function(t){return Number.isFinite(t[0])?t.length/this.positionSize:t.length}},{key:"getPointOnPath",value:function(t,e){if(Number.isFinite(t[0])){var n=this.positionSize;return[t[e*n],t[e*n+1],3===n?t[e*n+2]:0]}return t[e]}},{key:"isClosed",value:function(t){var e=this.getPathLength(t),n=this.getPointOnPath(t,0),i=this.getPointOnPath(t,e-1);return n[0]===i[0]&&n[1]===i[1]&&n[2]===i[2]}}]),e}(d),P="#define SHADER_NAME path-layer-fragment-shader\n\nprecision highp float;\n\nuniform float jointType;\nuniform float miterLimit;\nuniform float alignMode;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\nvarying vec2 vDashArray;\nvarying vec2 vPathPosition;\nvarying float vPathLength;\nfloat mod2(float a, float b) {\n  return a - floor(a / b) * b;\n}\n\nfloat round(float x) {\n  return floor(x + 0.5);\n}\nbool dash_isFragInGap() {\n  float solidLength = vDashArray.x;\n  float gapLength = vDashArray.y;\n\n  float unitLength = solidLength + gapLength;\n\n  if (unitLength == 0.0) {\n    return false;\n  }\n\n  unitLength = mix(\n    unitLength,\n    vPathLength / round(vPathLength / unitLength),\n    alignMode\n  );\n\n  float offset = alignMode * solidLength / 2.0;\n\n  return gapLength > 0.0 &&\n    vPathPosition.y >= 0.0 &&\n    vPathPosition.y <= vPathLength &&\n    mod2(vPathPosition.y + offset, unitLength) > solidLength;\n}\n\nvoid main(void) {\n  if (jointType > 0.0 && vMiterLength > 0.0 && length(vCornerOffset) > 1.0) {\n    discard;\n  }\n  if (jointType == 0.0 && vMiterLength > miterLimit) {\n    discard;\n  }\n  if (vColor.a == 0.0 || dash_isFragInGap()) {\n    discard;\n  }\n  gl_FragColor = vColor;\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\n}\n";n.d(e,"a",(function(){return b}));var m=[0,0,0,255],y={widthUnits:"meters",widthScale:{type:"number",min:0,value:1},widthMinPixels:{type:"number",min:0,value:0},widthMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},rounded:!1,miterLimit:{type:"number",min:0,value:4},fp64:!1,dashJustified:!1,billboard:!1,getPath:{type:"accessor",value:function(t){return t.path}},getColor:{type:"accessor",value:m},getWidth:{type:"accessor",value:1},getDashArray:{type:"accessor",value:[0,0]}},x={enter:function(t,e){return e.length?e.subarray(e.length-t.length):t}},b=function(t){function e(){return Object(i.a)(this,e),Object(s.a)(this,Object(r.a)(e).apply(this,arguments))}return Object(c.a)(e,t),Object(o.a)(e,[{key:"getShaders",value:function(){return this.use64bitProjection()?{vs:"\n#define SHADER_NAME path-layer-vertex-shader-64\n\nattribute vec3 positions;\n\nattribute vec3 instanceStartPositions;\nattribute vec3 instanceEndPositions;\nattribute vec4 instanceStartEndPositions64xyLow;\nattribute vec3 instanceLeftPositions;\nattribute vec3 instanceRightPositions;\nattribute vec4 instanceNeighborPositions64xyLow;\nattribute float instanceStrokeWidths;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\nattribute vec2 instanceDashArrays;\n\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform float jointType;\nuniform float miterLimit;\n\nuniform float opacity;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\nvarying vec2 vDashArray;\nvarying vec2 vPathPosition;\nvarying float vPathLength;\n\nconst float EPSILON = 0.001;\n\nfloat flipIfTrue(bool flag) {\n  return -(float(flag) * 2. - 1.);\n}\n\nvec3 lineJoin(vec2 prevPoint64[2], vec2 currPoint64[2], vec2 nextPoint64[2]) {\n\n  float widthPixels = clamp(project_size_to_pixel(instanceStrokeWidths * widthScale),\n    widthMinPixels, widthMaxPixels) / 2.0;\n  float width = project_pixel_size(widthPixels);\n\n  vec2 deltaA64[2];\n  vec2 deltaB64[2];\n\n  vec2_sub_fp64(currPoint64, prevPoint64, deltaA64);\n  vec2_sub_fp64(nextPoint64, currPoint64, deltaB64);\n\n  vec2 lengthA64 = vec2_length_fp64(deltaA64);\n  vec2 lengthB64 = vec2_length_fp64(deltaB64);\n\n  vec2 deltaA = vec2(deltaA64[0].x, deltaA64[1].x);\n  vec2 deltaB = vec2(deltaB64[0].x, deltaB64[1].x);\n\n  float lenA = lengthA64.x;\n  float lenB = lengthB64.x;\n\n  vec2 offsetVec;\n  float offsetScale;\n  float offsetDirection;\n  lenA = lenA / width > EPSILON ? lenA : 0.0;\n  lenB = lenB / width > EPSILON ? lenB : 0.0;\n  vec2 dirA = lenA > 0. ? deltaA / lenA : vec2(0.0, 0.0);\n  vec2 dirB = lenB > 0. ? deltaB / lenB : vec2(0.0, 0.0);\n\n  vec2 perpA = vec2(-dirA.y, dirA.x);\n  vec2 perpB = vec2(-dirB.y, dirB.x);\n  vec2 tangent = vec2(dirA + dirB);\n  tangent = length(tangent) > 0. ? normalize(tangent) : perpA;\n  vec2 miterVec = vec2(-tangent.y, tangent.x);\n  vec2 perp = mix(perpB, perpA, positions.x);\n  float L = mix(lenB, lenA, positions.x);\n  float sinHalfA = abs(dot(miterVec, perp));\n  float cosHalfA = abs(dot(dirA, miterVec));\n  bool turnsRight = dirA.x * dirB.y > dirA.y * dirB.x;\n  float cornerPosition = mix(\n    flipIfTrue(turnsRight == (positions.y > 0.0)),\n    0.0,\n    positions.z\n  );\n\n  offsetScale = 1.0 / max(sinHalfA, EPSILON);\n  cornerPosition *= float(cornerPosition <= 0.0 || sinHalfA < min(lenA, lenB) / width * cosHalfA);\n  offsetScale = mix(\n    offsetScale,\n    min(offsetScale, L / width / max(cosHalfA, EPSILON)),\n    float(cornerPosition < 0.0)\n  );\n\n  vMiterLength = mix(\n    offsetScale * cornerPosition,\n    mix(offsetScale, 0.0, cornerPosition),\n    step(0.0, cornerPosition)\n  ) - sinHalfA * jointType;\n  offsetDirection = mix(\n    positions.y,\n    mix(\n      flipIfTrue(turnsRight),\n      positions.y * flipIfTrue(turnsRight == (positions.x == 1.)),\n      cornerPosition\n    ),\n    step(0.0, cornerPosition)\n  );\n  offsetVec = mix(miterVec, -tangent, step(0.5, cornerPosition));\n  offsetScale = mix(offsetScale, 1.0 / max(cosHalfA, 0.001), step(0.5, cornerPosition));\n  float isStartCap = step(lenA, 1.0e-5);\n  float isEndCap = step(lenB, 1.0e-5);\n  float isCap = max(isStartCap, isEndCap);\n  cornerPosition = isCap * (1.0 - positions.z);\n  offsetVec = mix(offsetVec, mix(dirB, perpB, cornerPosition), isStartCap);\n  offsetVec = mix(offsetVec, mix(dirA, perpA, cornerPosition), isEndCap);\n  offsetScale = mix(\n    offsetScale,\n    mix(4.0 * jointType, 1.0, cornerPosition),\n    isCap\n  );\n  vMiterLength = mix(vMiterLength, 1.0 - cornerPosition, isCap);\n\n  offsetDirection = mix(\n    offsetDirection,\n    mix(flipIfTrue(isStartCap > 0.), positions.y, cornerPosition),\n    isCap\n  );\n\n  vCornerOffset = offsetVec * offsetDirection * offsetScale;\n  vDashArray = instanceDashArrays;\n  vPathLength = L / width;\n  float isEnd = positions.x;\n  vec2 offsetFromStartOfPath = mix(vCornerOffset, vCornerOffset + deltaA / width, isEnd);\n  vec2 dir = mix(dirB, dirA, isEnd);\n  vPathPosition = vec2(\n    positions.y + positions.z * offsetDirection,\n    dot(offsetFromStartOfPath, dir)\n  );\n\n  return vec3(vCornerOffset * width, 0.0);\n}\n\nvoid main() {\n  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity) / 255.;\n  picking_setPickingColor(instancePickingColors);\n\n  float isEnd = positions.x;\n\n  vec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);\n  vec2 currPosition64xyLow = mix(instanceStartEndPositions64xyLow.xy, instanceStartEndPositions64xyLow.zw, isEnd);\n  vec2 projected_curr_position[2];\n  project_position_fp64(currPosition.xy, currPosition64xyLow, projected_curr_position);\n  float projected_curr_position_z = project_size(currPosition.z);\n\n  vec3 prevPosition = mix(instanceLeftPositions, instanceStartPositions, isEnd);\n  vec2 prevPosition64xyLow = mix(instanceNeighborPositions64xyLow.xy, instanceStartEndPositions64xyLow.xy, isEnd);\n\n  vec2 projected_prev_position[2];\n  project_position_fp64(prevPosition.xy, prevPosition64xyLow, projected_prev_position);\n  vec3 nextPosition = mix(instanceEndPositions, instanceRightPositions, isEnd);\n  vec2 nextPosition64xyLow = mix(instanceStartEndPositions64xyLow.zw, instanceNeighborPositions64xyLow.zw, isEnd);\n\n  vec2 projected_next_position[2];\n  project_position_fp64(nextPosition.xy, nextPosition64xyLow, projected_next_position);\n\n  vec3 pos = lineJoin(projected_prev_position, projected_curr_position, projected_next_position);\n  vec2 vertex_pos_modelspace[4];\n\n  vertex_pos_modelspace[0] = sum_fp64(vec2(pos.x, 0.0), projected_curr_position[0]);\n  vertex_pos_modelspace[1] = sum_fp64(vec2(pos.y, 0.0), projected_curr_position[1]);\n  vertex_pos_modelspace[2] = vec2(pos.z + projected_curr_position_z, 0.0);\n  vertex_pos_modelspace[3] = vec2(1.0, 0.0);\n\n  gl_Position = project_common_position_to_clipspace_fp64(vertex_pos_modelspace);\n}\n",fs:P,modules:["project64","picking"]}:{vs:"#define SHADER_NAME path-layer-vertex-shader\n\nattribute vec3 positions;\n\nattribute vec3 instanceStartPositions;\nattribute vec3 instanceEndPositions;\nattribute vec4 instanceStartEndPositions64xyLow;\nattribute vec3 instanceLeftPositions;\nattribute vec3 instanceRightPositions;\nattribute vec4 instanceNeighborPositions64xyLow;\nattribute float instanceStrokeWidths;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\nattribute vec2 instanceDashArrays;\n\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform float jointType;\nuniform float miterLimit;\nuniform bool billboard;\n\nuniform float opacity;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\nvarying vec2 vDashArray;\nvarying vec2 vPathPosition;\nvarying float vPathLength;\n\nconst float EPSILON = 0.001;\nconst vec3 ZERO_OFFSET = vec3(0.0);\n\nfloat flipIfTrue(bool flag) {\n  return -(float(flag) * 2. - 1.);\n}\nvec3 lineJoin(\n  vec3 prevPoint, vec3 currPoint, vec3 nextPoint,\n  float relativePosition, bool isEnd, bool isJoint,\n  vec2 width\n) {\n  vec2 deltaA = (currPoint.xy - prevPoint.xy) / width;\n  vec2 deltaB = (nextPoint.xy - currPoint.xy) / width;\n\n  float lenA = length(deltaA);\n  float lenB = length(deltaB);\n  lenA = lenA > EPSILON ? lenA : 0.0;\n  lenB = lenB > EPSILON ? lenB : 0.0;\n\n  vec2 dirA = lenA > 0. ? normalize(deltaA) : vec2(0.0, 0.0);\n  vec2 dirB = lenB > 0. ? normalize(deltaB) : vec2(0.0, 0.0);\n\n  vec2 perpA = vec2(-dirA.y, dirA.x);\n  vec2 perpB = vec2(-dirB.y, dirB.x);\n  vec2 tangent = vec2(dirA + dirB);\n  tangent = length(tangent) > 0. ? normalize(tangent) : perpA;\n  vec2 miterVec = vec2(-tangent.y, tangent.x);\n  vec2 perp = isEnd ? perpA : perpB;\n  float L = isEnd ? lenA : lenB;\n  float sinHalfA = abs(dot(miterVec, perp));\n  float cosHalfA = abs(dot(dirA, miterVec));\n\n  bool turnsRight = dirA.x * dirB.y > dirA.y * dirB.x;\n\n  float offsetScale = 1.0 / max(sinHalfA, EPSILON);\n\n  float cornerPosition = isJoint ?\n    0.0 :\n    flipIfTrue(turnsRight == (relativePosition > 0.0));\n  cornerPosition *=\n    float(cornerPosition <= 0.0 || sinHalfA < min(lenA, lenB) * cosHalfA);\n  if (cornerPosition < 0.0) {\n    offsetScale = min(offsetScale, L / max(cosHalfA, EPSILON));\n  }\n\n  vMiterLength = cornerPosition >= 0.0 ?\n    mix(offsetScale, 0.0, cornerPosition) :\n    offsetScale * cornerPosition;\n  vMiterLength -= sinHalfA * jointType;\n\n  float offsetDirection = mix(\n    positions.y,\n    mix(\n      flipIfTrue(turnsRight),\n      positions.y * flipIfTrue(turnsRight == (positions.x == 1.)),\n      cornerPosition\n    ),\n    step(0.0, cornerPosition)\n  );\n\n  vec2 offsetVec = mix(miterVec, -tangent, step(0.5, cornerPosition));\n  offsetScale = mix(offsetScale, 1.0 / max(cosHalfA, 0.001), step(0.5, cornerPosition));\n  bool isStartCap = step(0.0, -lenA) > 0.5;\n  bool isEndCap = step(0.0, -lenB) > 0.5;\n  bool isCap = isStartCap || isEndCap;\n  cornerPosition = isCap ? (1.0 - positions.z) : 0.;\n  if (isStartCap) {\n    offsetVec = mix(dirB, perpB, cornerPosition);\n  }\n  if (isEndCap) {\n    offsetVec = mix(dirA, perpA, cornerPosition);\n  }\n  if (isCap) {\n    offsetScale = mix(4.0 * jointType, 1.0, cornerPosition);\n    vMiterLength = 1.0 - cornerPosition;\n    offsetDirection = mix(flipIfTrue(isStartCap), positions.y, cornerPosition);\n  }\n\n  vCornerOffset = offsetVec * offsetDirection * offsetScale;\n  vDashArray = instanceDashArrays;\n  vPathLength = L;\n  vec2 offsetFromStartOfPath = vCornerOffset;\n  if (isEnd) {\n    offsetFromStartOfPath += deltaA;\n  }\n  vec2 dir = isEnd ? dirA : dirB;\n  vPathPosition = vec2(\n    positions.y + positions.z * offsetDirection,\n    dot(offsetFromStartOfPath, dir)\n  );\n\n  return currPoint + vec3(vCornerOffset * width, 0.0);\n}\nvec3 lineJoin(vec3 prevPoint, vec3 currPoint, vec3 nextPoint) {\n\n  float relativePosition = positions.y;\n  bool isEnd = positions.x > EPSILON;\n  bool isJoint = positions.z > EPSILON;\n\n  vec2 widthPixels = vec2(clamp(project_size_to_pixel(instanceStrokeWidths * widthScale),\n    widthMinPixels, widthMaxPixels) / 2.0);\n\n  return lineJoin(\n    prevPoint, currPoint, nextPoint,\n    relativePosition, isEnd, isJoint,\n    billboard ? project_pixel_size_to_clipspace(widthPixels) : project_pixel_size(widthPixels)\n  );\n}\nvoid clipLine(inout vec4 position, vec4 refPosition) {\n  if (position.w < EPSILON) {\n    float r = (EPSILON - refPosition.w) / (position.w - refPosition.w);\n    position = refPosition + (position - refPosition) * r;\n  }\n}\n\nvoid main() {\n  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity) / 255.;\n  picking_setPickingColor(instancePickingColors);\n\n  float isEnd = positions.x;\n\n  vec3 prevPosition = mix(instanceLeftPositions, instanceStartPositions, isEnd);\n  vec2 prevPosition64xyLow = mix(instanceNeighborPositions64xyLow.xy, instanceStartEndPositions64xyLow.xy, isEnd);\n\n  vec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);\n  vec2 currPosition64xyLow = mix(instanceStartEndPositions64xyLow.xy, instanceStartEndPositions64xyLow.zw, isEnd);\n\n  vec3 nextPosition = mix(instanceEndPositions, instanceRightPositions, isEnd);\n  vec2 nextPosition64xyLow = mix(instanceStartEndPositions64xyLow.zw, instanceNeighborPositions64xyLow.zw, isEnd);\n\n  if (billboard) {\n    vec4 prevPositionScreen = project_position_to_clipspace(prevPosition, prevPosition64xyLow, ZERO_OFFSET);\n    vec4 currPositionScreen = project_position_to_clipspace(currPosition, currPosition64xyLow, ZERO_OFFSET);\n    vec4 nextPositionScreen = project_position_to_clipspace(nextPosition, nextPosition64xyLow, ZERO_OFFSET);\n\n    clipLine(prevPositionScreen, currPositionScreen);\n    clipLine(nextPositionScreen, currPositionScreen);\n    clipLine(currPositionScreen, mix(nextPositionScreen, prevPositionScreen, isEnd));\n\n    vec3 pos = lineJoin(\n      prevPositionScreen.xyz / prevPositionScreen.w,\n      currPositionScreen.xyz / currPositionScreen.w,\n      nextPositionScreen.xyz / nextPositionScreen.w\n    );\n\n    gl_Position = vec4(pos * currPositionScreen.w, currPositionScreen.w);\n  } else {\n    prevPosition = project_position(prevPosition, prevPosition64xyLow);\n    currPosition = project_position(currPosition, currPosition64xyLow);\n    nextPosition = project_position(nextPosition, nextPosition64xyLow);\n\n    vec3 pos = lineJoin(prevPosition, currPosition, nextPosition);\n    gl_Position = project_common_position_to_clipspace(vec4(pos, 1.0));\n  }\n}\n",fs:P,modules:["project32","picking"]}}},{key:"initializeState",value:function(){var t=this;this.getAttributeManager().addInstanced({instanceStartPositions:{size:3,transition:x,accessor:"getPath",update:this.calculateStartPositions,noAlloc:!0},instanceEndPositions:{size:3,transition:x,accessor:"getPath",update:this.calculateEndPositions,noAlloc:!0},instanceStartEndPositions64xyLow:{size:4,update:this.calculateInstanceStartEndPositions64xyLow,noAlloc:!0},instanceLeftPositions:{size:3,accessor:"getPath",update:this.calculateLeftPositions,noAlloc:!0},instanceRightPositions:{size:3,accessor:"getPath",update:this.calculateRightPositions,noAlloc:!0},instanceNeighborPositions64xyLow:{size:4,update:this.calculateInstanceNeighborPositions64xyLow,noAlloc:!0},instanceStrokeWidths:{size:1,accessor:"getWidth",transition:x,defaultValue:1},instanceDashArrays:{size:2,accessor:"getDashArray"},instanceColors:{size:4,type:5121,accessor:"getColor",transition:x,defaultValue:m},instancePickingColors:{size:3,type:5121,accessor:function(e,n){var i=n.index,o=n.target;return t.encodePickingColor(i,o)}}}),this.setState({pathTesselator:new v({})})}},{key:"updateState",value:function(t){var n=t.oldProps,i=t.props,o=t.changeFlags;Object(a.a)(Object(r.a)(e.prototype),"updateState",this).call(this,{props:i,oldProps:n,changeFlags:o});var s=this.getAttributeManager();if(o.dataChanged||i.fp64!==n.fp64||o.updateTriggersChanged&&(o.updateTriggersChanged.all||o.updateTriggersChanged.getPath)){var c=this.state.pathTesselator;c.updateGeometry({data:i.data,getGeometry:i.getPath,positionFormat:i.positionFormat,fp64:this.use64bitPositions()}),this.setState({numInstances:c.instanceCount,bufferLayout:c.bufferLayout}),s.invalidateAll()}if(i.fp64!==n.fp64){var l=this.context.gl;this.state.model&&this.state.model.delete(),this.setState({model:this._getModel(l)}),s.invalidateAll()}}},{key:"draw",value:function(t){var e=t.uniforms,n=this.context.viewport,i=this.props,o=i.rounded,s=i.billboard,r=i.miterLimit,a=i.widthUnits,c=i.widthScale,l=i.widthMinPixels,p=i.widthMaxPixels,f=i.dashJustified,u="pixels"===a?n.distanceScales.metersPerPixel[2]:1;this.state.model.setUniforms(Object.assign({},e,{jointType:Number(o),billboard:s,alignMode:Number(f),widthScale:c*u,miterLimit:r,widthMinPixels:l,widthMaxPixels:p})).draw()}},{key:"_getModel",value:function(t){return new p.a(t,Object.assign({},this.getShaders(),{id:this.props.id,geometry:new f.a({drawMode:4,attributes:{indices:new Uint16Array([0,2,1,1,2,4,1,4,3,3,4,5]),positions:new Float32Array([0,0,1,0,-1,0,0,1,0,1,-1,0,1,1,0,1,0,1])}}),isInstanced:!0,shaderCache:this.context.shaderCache}))}},{key:"calculateStartPositions",value:function(t){var e=this.state.pathTesselator;t.bufferLayout=e.bufferLayout,t.value=e.get("startPositions")}},{key:"calculateEndPositions",value:function(t){var e=this.state.pathTesselator;t.bufferLayout=e.bufferLayout,t.value=e.get("endPositions")}},{key:"calculateInstanceStartEndPositions64xyLow",value:function(t){var e=this.use64bitPositions();t.constant=!e,t.value=e?this.state.pathTesselator.get("startEndPositions64XyLow"):new Float32Array(4)}},{key:"calculateLeftPositions",value:function(t){var e=this.state.pathTesselator;t.value=e.get("leftPositions")}},{key:"calculateRightPositions",value:function(t){var e=this.state.pathTesselator;t.value=e.get("rightPositions")}},{key:"calculateInstanceNeighborPositions64xyLow",value:function(t){var e=this.use64bitPositions();t.constant=!e,t.value=e?this.state.pathTesselator.get("neighborPositions64XyLow"):new Float32Array(4)}},{key:"clearPickingColor",value:function(t){for(var e=this.decodePickingColor(t),n=this.state.pathTesselator.bufferLayout,i=n[e],o=0,s=0;s<e;s++)o+=n[s];var r=this.getAttributeManager().attributes.instancePickingColors,a=r.value,c=o+i;a.fill(0,3*o,3*c),r.update({value:a})}}]),e}(l.a);b.layerName="PathLayer",b.defaultProps=y},1134:function(t,e,n){"use strict";n.r(e),n.d(e,"getLayer",(function(){return u}));var i=n(1022),o=n(1),s=n.n(o),r=n(962),a=n(956),c=n(971),l=n(964);function p(){return(p=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var i in n)Object.prototype.hasOwnProperty.call(n,i)&&(t[i]=n[i])}return t}).apply(this,arguments)}function f(t){return t.object.extraProps&&s.a.createElement("div",{className:"deckgl-tooltip"},Object.keys(t.object.extraProps).map((e,n)=>s.a.createElement(l.a,{key:"prop-"+n,label:e+": ",value:""+t.object.extraProps[e]})))}function u(t,e,n,o){const s=t,c=s.color_picker,l=[c.r,c.g,c.b,255*c.a];let u=e.data.features.map(t=>p({},t,{path:t.path,width:s.line_width,color:l}));if(s.js_data_mutator){u=Object(a.a)(s.js_data_mutator)(u)}return new i.a(p({id:"path-layer-"+s.slice_id,getColor:t=>t.color,getPath:t=>t.path,getWidth:t=>t.width,data:u,rounded:!0,widthScale:1},Object(r.a)(s,o,f)))}e.default=Object(c.b)(u,(function(t){let e=[];return t.forEach(t=>{e=e.concat(t.path)}),e}))},471:function(t,e,n){"use strict";var i={};n.r(i),n.d(i,"default",(function(){return p})),n.d(i,"DEFAULT_NAMESPACE",(function(){return u})),n.d(i,"getNamespace",(function(){return h})),n.d(i,"getColor",(function(){return d})),n.d(i,"getScale",(function(){return g}));var o=n(140),s=n(942);function r(t){return String(t).trim()}class a extends s.a{constructor(t,e){super(t=>this.getColor(t)),this.colors=t,this.scale=Object(o.a)(),this.scale.range(t),this.parentForcedColors=e,this.forcedColors={}}getColor(t){const e=r(t),n=this.parentForcedColors&&this.parentForcedColors[e];if(n)return n;const i=this.forcedColors[e];return i||this.scale(e)}setColor(t,e){return this.forcedColors[r(t)]=e,this}getColorMap(){const t={};return this.scale.domain().forEach(e=>{t[e.toString()]=this.scale(e)}),{...t,...this.forcedColors,...this.parentForcedColors}}copy(){const t=new a(this.scale.range(),this.parentForcedColors);return t.forcedColors={...this.forcedColors},t.domain(this.domain()),t.unknown(this.unknown()),t}domain(t){return void 0===t?this.scale.domain():(this.scale.domain(t),this)}range(t){return void 0===t?this.scale.range():(this.colors=t,this.scale.range(t),this)}unknown(t){return void 0===t?this.scale.unknown():(this.scale.unknown(t),this)}}var c=a,l=n(469);class p{constructor(t){this.name=t,this.scales={},this.forcedItems={}}getScale(t){var e,n;const i=null!=(e=null!=t?t:Object(l.a)().getDefaultKey())?e:"",o=this.scales[i];if(o)return o;const s=Object(l.a)().get(i),r=new c(null!=(n=null==s?void 0:s.colors)?n:[],this.forcedItems);return this.scales[i]=r,r}setColor(t,e){return this.forcedItems[r(t)]=e,this}}const f={},u="GLOBAL";function h(t=u){const e=f[t];if(e)return e;const n=new p(t);return f[t]=n,n}function d(t,e,n){return h(n).getScale(e).getColor(t)}function g(t,e){return h(e).getScale(t)}n.d(e,"a",(function(){return i}))},971:function(t,e,n){"use strict";var i=n(1),o=n.n(i),s=n(0),r=n.n(s),a=n(287),c=n(970),l=n(471),p=n(976),f=n(972),u=n(965),h=n(975),d=n(956),g=n(968);function v(){return(v=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var i in n)Object.prototype.hasOwnProperty.call(n,i)&&(t[i]=n[i])}return t}).apply(this,arguments)}function P(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}const{getScale:m}=l.a;const y={formData:r.a.object.isRequired,mapboxApiKey:r.a.string.isRequired,setControlValue:r.a.func.isRequired,viewport:r.a.object.isRequired,getLayer:r.a.func.isRequired,getPoints:r.a.func.isRequired,payload:r.a.object.isRequired,onAddFilter:r.a.func,width:r.a.number.isRequired,height:r.a.number.isRequired};class x extends o.a.PureComponent{constructor(t){super(t),P(this,"containerRef",o.a.createRef()),P(this,"setTooltip",t=>{const{current:e}=this.containerRef;e&&e.setTooltip(t)}),this.state=this.getStateFromProps(t),this.getLayers=this.getLayers.bind(this),this.onValuesChange=this.onValuesChange.bind(this),this.toggleCategory=this.toggleCategory.bind(this),this.showSingleCategory=this.showSingleCategory.bind(this)}UNSAFE_componentWillReceiveProps(t){t.payload.form_data!==this.state.formData&&this.setState(v({},this.getStateFromProps(t)))}onValuesChange(t){this.setState({values:Array.isArray(t)?t:[t,t+this.state.getStep(t)]})}getStateFromProps(t,e){const n=t.payload.data.features||[],i=n.map(t=>t.__timestamp),o=function(t,e){const n=t.color_picker||{r:0,g:0,b:0,a:1},i=[n.r,n.g,n.b,255*n.a],o=m(t.color_scheme),s={};return e.forEach(e=>{if(null!=e.cat_color&&!s.hasOwnProperty(e.cat_color)){let r;r=t.dimension?Object(u.hexToRGB)(o(e.cat_color),255*n.a):i,s[e.cat_color]={color:r,enabled:!0}}}),s}(t.formData,n);if(e&&t.payload.form_data===e.formData)return v({},e,{categories:o});const s=t.payload.form_data.time_grain_sqla||t.payload.form_data.granularity||"P1D",{start:r,end:a,getStep:c,values:l,disabled:p}=Object(h.a)(i,s),{width:f,height:d,formData:P}=t;let{viewport:y}=t;return P.autozoom&&(y=Object(g.a)(y,{width:f,height:d,points:t.getPoints(n)})),{start:r,end:a,getStep:c,values:l,disabled:p,viewport:y,selected:[],lastClick:0,formData:t.payload.form_data,categories:o}}getLayers(t){const{getLayer:e,payload:n,formData:i,onAddFilter:o}=this.props;let s=n.data.features?[...n.data.features]:[];if(s=this.addColor(s,i),i.js_data_mutator){s=Object(d.a)(i.js_data_mutator)(s)}s=t[0]===t[1]||t[1]===this.end?s.filter(e=>e.__timestamp>=t[0]&&e.__timestamp<=t[1]):s.filter(e=>e.__timestamp>=t[0]&&e.__timestamp<t[1]);const r=this.state.categories;return i.dimension&&(s=s.filter(t=>r[t.cat_color]&&r[t.cat_color].enabled)),[e(i,v({},n,{data:v({},n.data,{features:s})}),o,this.setTooltip)]}addColor(t,e){const n=e.color_picker||{r:0,g:0,b:0,a:1},i=m(e.color_scheme);return t.map(t=>{let o;return e.dimension?(o=Object(u.hexToRGB)(i(t.cat_color),255*n.a),v({},t,{color:o})):t})}toggleCategory(t){const e=this.state.categories[t],n=v({},this.state.categories,{[t]:v({},e,{enabled:!e.enabled})});Object.values(n).every(t=>!t.enabled)&&Object.values(n).forEach(t=>{t.enabled=!0}),this.setState({categories:n})}showSingleCategory(t){const e=v({},this.state.categories);Object.values(e).forEach(t=>{t.enabled=!1}),e[t].enabled=!0,this.setState({categories:e})}render(){return o.a.createElement("div",{style:{position:"relative"}},o.a.createElement(p.a,{ref:this.containerRef,getLayers:this.getLayers,start:this.state.start,end:this.state.end,getStep:this.state.getStep,values:this.state.values,disabled:this.state.disabled,viewport:this.state.viewport,mapboxApiAccessToken:this.props.mapboxApiKey,mapStyle:this.props.formData.mapbox_style,setControlValue:this.props.setControlValue,width:this.props.width,height:this.props.height},o.a.createElement(f.a,{categories:this.state.categories,toggleCategory:this.toggleCategory,showSingleCategory:this.showSingleCategory,position:this.props.formData.legend_position,format:this.props.formData.legend_format})))}}function b(){return(b=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var i in n)Object.prototype.hasOwnProperty.call(n,i)&&(t[i]=n[i])}return t}).apply(this,arguments)}function _(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}x.propTypes=y,n.d(e,"b",(function(){return A})),n.d(e,"a",(function(){return L}));const S={formData:r.a.object.isRequired,payload:r.a.object.isRequired,setControlValue:r.a.func.isRequired,viewport:r.a.object.isRequired,onAddFilter:r.a.func,width:r.a.number.isRequired,height:r.a.number.isRequired},w={onAddFilter(){}};function A(t,e){class n extends o.a.PureComponent{constructor(t){super(t),_(this,"containerRef",o.a.createRef()),_(this,"setTooltip",t=>{const{current:e}=this.containerRef;e&&e.setTooltip(t)});const{width:n,height:i,formData:s}=t;let{viewport:r}=t;s.autozoom&&(r=Object(g.a)(r,{width:n,height:i,points:e(t.payload.data.features)})),this.state={viewport:r,layer:this.computeLayer(t)},this.onViewportChange=this.onViewportChange.bind(this)}UNSAFE_componentWillReceiveProps(t){const e=b({},t.formData,{viewport:null}),n=b({},this.props.formData,{viewport:null});Object(a.isEqual)(e,n)&&t.payload===this.props.payload||this.setState({layer:this.computeLayer(t)})}onViewportChange(t){this.setState({viewport:t})}computeLayer(e){const{formData:n,payload:i,onAddFilter:o}=e;return t(n,i,o,this.setTooltip)}render(){const{formData:t,payload:e,setControlValue:n,height:i,width:s}=this.props,{layer:r,viewport:a}=this.state;return o.a.createElement(c.a,{ref:this.containerRef,mapboxApiAccessToken:e.data.mapboxApiKey,viewport:a,layers:[r],mapStyle:t.mapbox_style,setControlValue:n,width:s,height:i,onViewportChange:this.onViewportChange})}}return n.propTypes=S,n.defaultProps=w,n}function L(t,e){function n(n){const{formData:i,payload:s,setControlValue:r,viewport:a,width:c,height:l}=n;return o.a.createElement(x,{formData:i,mapboxApiKey:s.data.mapboxApiKey,setControlValue:r,viewport:a,getLayer:t,payload:s,getPoints:e,width:c,height:l})}return n.propTypes=S,n.defaultProps=w,n}},972:function(t,e,n){"use strict";n.d(e,"a",(function(){return l}));var i=n(1),o=n.n(i),s=n(0),r=n.n(s),a=n(1021);n(973);const c={categories:r.a.object,toggleCategory:r.a.func,showSingleCategory:r.a.func,format:r.a.string,position:r.a.oneOf([null,"tl","tr","bl","br"])};class l extends o.a.PureComponent{format(t){if(!this.props.format)return t;const e=parseFloat(t);return Object(a.a)(this.props.format,e)}formatCategoryLabel(t){if(!this.props.format)return t;if(t.includes(" - ")){const e=t.split(" - ");return this.format(e[0])+" - "+this.format(e[1])}return this.format(t)}render(){if(0===Object.keys(this.props.categories).length||null===this.props.position)return null;const t=Object.entries(this.props.categories).map(t=>{let[e,n]=t;const i={color:"rgba("+n.color.join(", ")+")"},s=n.enabled?"◼":"◻";return o.a.createElement("li",{key:e},o.a.createElement("a",{href:"#",onClick:()=>this.props.toggleCategory(e),onDoubleClick:()=>this.props.showSingleCategory(e)},o.a.createElement("span",{style:i},s)," ",this.formatCategoryLabel(e)))}),e={position:"absolute",["t"===this.props.position.charAt(0)?"top":"bottom"]:"0px",["r"===this.props.position.charAt(1)?"right":"left"]:"10px"};return o.a.createElement("div",{className:"legend",style:e},o.a.createElement("ul",{className:"categories"},t))}}l.propTypes=c,l.defaultProps={categories:{},toggleCategory:()=>{},showSingleCategory:()=>{},format:null,position:"tr"}},973:function(t,e,n){var i=n(466),o=n(974);"string"==typeof(o=o.__esModule?o.default:o)&&(o=[[t.i,o,""]]);var s={insert:"head",singleton:!1},r=(i(o,s),o.locals?o.locals:{});t.exports=r},974:function(t,e,n){(e=n(467)(!1)).push([t.i,'/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * "License"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\ndiv.legend {\n  font-size: 90%;\n  position: absolute;\n  background: #fff;\n  box-shadow: 0 0 4px rgba(0, 0, 0, 0.15);\n  margin: 24px;\n  padding: 12px 20px;\n  outline: none;\n  overflow-y: scroll;\n  max-height: 200px;\n}\n\nul.categories {\n  list-style: none;\n  padding-left: 0;\n  margin: 0;\n}\n\nul.categories li a {\n  color: rgb(51, 51, 51);\n  text-decoration: none;\n}\n\nul.categories li a span {\n  margin-right: 10px;\n}\n',""]),t.exports=e}}]);